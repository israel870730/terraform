Pre-requisite
You have installed the Product Catalog Application using Helm. For more information refer to Helm chapter

You have installed the EBS CSI driver and created mysql-gp2 storage class. For more information refer to EBS CSI Driver chapter

In this chapter we will show how AWS Key Management Service KMS  is used to encrypt Kubernetes Secrets and how to access the encrypted secrets in EKS pods as environment variables.

We will also show how secrets from AWS Secrets Manager (https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html) are mounted on EKS pods as volumes by using AWS Secrets and Configuration Provider ASCP (https://github.com/aws/secrets-store-csi-driver-provider-aws) for Kubernetes Secrets Store CSI Driver (https://secrets-store-csi-driver.sigs.k8s.io/).

Encrypting Kubernetes Secrets
Kubernetes can store secrets (https://kubernetes.io/docs/concepts/configuration/secret/) that pods can access via a mounted volume or environment variable. 
Today, Kubernetes secrets are stored with Base64 encoding, but security teams would prefer a stronger approach. 
Amazon EKS clusters version 1.13 and higher support the capability of encrypting your Kubernetes secrets using AWS Key Management Service (KMS) Customer Managed Keys (CMK). 
There are no changes required in the way you are using secrets. The only requirement is to enable the encryption provider support during EKS cluster creation.

Typically the following happens when you create a Kubernetes Secret in an EKS cluster:

The user (typically in an admin role) creates a secret.
The Kubernetes API server in the EKS control plane generates a Data Encryption Key (DEK) locally and uses it to encrypt the plaintext payload in the secret. Note that the control plane generates a unique DEK for every single write, and the plaintext DEK is never saved to disk.
The Kubernetes API server calls kms:Encrypt to encrypt the DEK with the CMK. In this step, the API server uses the CMK to encrypt the DEK and also caches the base64 of the encrypted DEK.
The API server stores the DEK-encrypted secret in etcd.
If one now wants to use the secret in, say a pod via a volume (read-path), the reverse process takes place. That is, the API server reads the encrypted secret from etcd and decrypts the secret with the DEK.
The application, running in a pod on either EC2 or Fargate, can then consume the secret as usual.

Mounting Secrets from AWS Secrets Manager
We can use AWS Secrets Manager (https://docs.aws.amazon.com/secretsmanager/latest/userguide/integrating_csi_driver.html) to store our secrets and the secrets stored in AWS Secrets Manager  can be mounted as volumes in EKS pods using the AWS Secrets and Configuration Provider (ASCP) (https://github.com/aws/secrets-store-csi-driver-provider-aws) for Kubernetes Secrets Store CSI Driver (https://secrets-store-csi-driver.sigs.k8s.io/).

By Using ASCP, you can retrieve secrets from AWS Secrets Manager  through your pods running on EKS. The values from secrets are available as projected volumes in your pod. 
The ASCP retrieves the pod identity and exchanges identity for an IAM role for a Service Account(IRSA) (https://aws.amazon.com/es/blogs/opensource/introducing-fine-grained-iam-roles-service-accounts/) . 
It allows to limiting access to your secrets to specific pods from a namespace in the EKS cluster.

The CSI driver can also sync your mounted secret volumes with a native Kubernetes secrets. 
The secrets from AWS Secrets Manager has to be mounted as volume mounts and only after that the CSI driver will create Kubernetes secret object based on the secrets mounted as volume in the pod. 
You can then also populate Environment variables within a pod from Kubernetes secrets.

Typically following steps has to be followed when you want create a secret in AWS Secrets Manager and use the secret in an EKS pod

Create a secret with the AWS Secrets Manager.
Create an IAM policy to retrieve a secret from the AWS Secrets Manager.
Use IRSA to limit secret access to your pods in a specific namespace.
Create and deploy SecretProviderClass custom resource and by using provider: aws
Deploy your pods to mount the volumes based on SecretProviderClass configured earlier.
Sync your secrets from mounted volumes to the native Kubernetes secrets object.
Set up Environment variables in the pod, by selecting a specific key of your secret.