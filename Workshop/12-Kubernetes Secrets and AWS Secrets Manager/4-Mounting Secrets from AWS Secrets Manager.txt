Pre-requisite
We assume that you have completed the chapter Deploy Statefulset and have MYSQL database up and running.
Secrets Store CSI Driver and ASCP
We have the MYSQL StatefulSet deployed and now we are going to save the password for the MYSQL database in AWS Secrets Manager and sync the secrets manager secret to a Native Kubernertes secret using the Secrets Store CSI driver. The Kubernetes secret created by the CSI driver will be used in the productcatalog service to connect to the MYSQL Database.

Install CSI Driver
Prepare your cluster by installing Secrets Store CSI Secret driver and AWS Secrets and Configuration Provider (ASCP).

Secrets Store CSI Driver
helm repo add secrets-store-csi-driver \
https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts

helm install -n kube-system csi-secrets-store \
--set syncSecret.enabled=true \
--set enableSecretRotation=true \
secrets-store-csi-driver/secrets-store-csi-driver

ASCP

kubectl apply -f https://raw.githubusercontent.com/aws/secrets-store-csi-driver-provider-aws/main/deployment/aws-provider-installer.yaml

Verify that two daemonsets deployed. csi-secrets-store-secrets-store-csi-driver for standard Secrets Store CSI Driver and csi-secrets-store-provider-aws for the ASCP that supports provider (AWS) specific options.

kubectl get daemonsets -n kube-system -l app=csi-secrets-store-provider-aws
kubectl get daemonsets -n kube-system -l app.kubernetes.io/instance=csi-secrets-store

Prepare Secret and IAM access
Lets just start with preparing the environment

export CLUSTER_NAME=eksworkshop-eksctl

Create a test secret in AWS Secrets Manager

aws secretsmanager create-secret \
--name DBSecret_eksworkshop \
--description "MYSQL DB Secret." \
--secret-string "{\"username\":\"root\",\"password\":\"test1234\"}"


Get Secret’s ARN

export SECRET_ARN=$(aws secretsmanager \
describe-secret --secret-id DBSecret_eksworkshop \
--query 'ARN' | sed -e 's/"//g' )

echo $SECRET_ARN

You can also verify the newly created secret via AWS console under AWS Secrets Manager 

Create an IAM policy with permissions to access the secrets manager secret.

export IAM_POLICY_NAME_SECRET="DBSecret_eksworkshop_secrets_policy"
export IAM_POLICY_ARN_SECRET=$(aws iam \
create-policy --query Policy.Arn \
--output text --policy-name $IAM_POLICY_NAME_SECRET \
--policy-document '{
"Version": "2012-10-17",
"Statement": [ {
"Effect": "Allow",
"Action": ["secretsmanager:GetSecretValue", "secretsmanager:DescribeSecret"],
"Resource": ["'"$SECRET_ARN"'" ]
} ]
}')

echo $IAM_POLICY_ARN_SECRET | tee -a 00_iam_policy_arn_dbsecret

Create an IAM Service Account to access the secrets manager secret

eksctl utils associate-iam-oidc-provider --cluster eksworkshop-eksctl --approve

eksctl create iamserviceaccount \
--name "catalog-deployment-sa" \
--cluster "$CLUSTER_NAME" \
--attach-policy-arn "$IAM_POLICY_ARN_SECRET" --approve \
--namespace workshop \
--override-existing-serviceaccounts

Sync with Native Kubernetes Secrets
Create SecretProviderClass to extract key-value pairs
Let’s create a SecretProviderClass custom resource and use jmesPath field in the spec file. Use of jmesPath (https://jmespath.org/) allows extracting specific key-value from a JSON-formatted secret.
It is a provider-specific feature from ASCP (https://github.com/aws/secrets-store-csi-driver-provider-aws).

secretObjects spec section allows specifying the Kubernetes native secret structure synced from the objects: extracted from the JSON formatted secret using jmesPath. 
The feature is provided by the standard Secret Store CSI Driver. (https://secrets-store-csi-driver.sigs.k8s.io/topics/sync-as-kubernetes-secret.html)

cat << EOF > catalog-deployment-spc-k8s-secrets.yaml
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: catalog-deployment-spc-k8s-secrets
  namespace: workshop
spec:
  provider: aws
  parameters: 
    objects: |
      - objectName: "DBSecret_eksworkshop"
        objectType: "secretsmanager"
        jmesPath:
          - path: username
            objectAlias: dbusername
          - path: password
            objectAlias: dbpassword
  # Create k8s secret. It requires volume mount first in the pod and then sync.
  secretObjects:                
    - secretName: mysql-secret-from-secrets-manager
      type: Opaque
      data:
        #- objectName: <objectName> or <objectAlias> 
        - objectName: dbusername
          key: db_username
        - objectName: dbpassword
          key: db_password
EOF


Create custom resource
kubectl apply -f catalog-deployment-spc-k8s-secrets.yaml

kubectl -n workshop get SecretProviderClass catalog-deployment-spc-k8s-secrets

The output indicates the resource catalog-deployment-spc-k8s-secrets created successfully.

NAME                               AGE
catalog-deployment-spc-k8s-secrets 10s

Create Pod Mount Secrets Volumes and set up Environment variables

Now let us Configure productcatalog service pod to mount volumes for individually extracted key-value pairs from the secrets.
Once the pod is created with secrets volume mounts, the Secrets Store CSI Driver then creates and syncs Kubernetes secret object mysql-secret-from-secrets-manager. 
The pod then be able to populate Environment variables from the Kubernetes secret.


cd ~/environment/eks-app-mesh-polyglot-demo
helm upgrade --reuse-values -f ~/environment/eks-app-mesh-polyglot-demo/workshop/helm-chart/values-secrets-manager.yaml workshop workshop/helm-chart/

Now we have the following setup as shown below. The secret from AWS secret manager is synced to a native Kubernetes secret with the help of Secretes Store CSI driver.

Verify the result
Make sure the workshop application is still working and you are able to add / retrieve products.

Get the Loadbalancer url
export LB_NAME=$(kubectl get svc frontend -n workshop -o jsonpath="{.status.loadBalancer.ingress[*].hostname}")
echo $LB_NAME

It will show the product you created while deploying the MYSQL database in the Product Application UI.

Get a shell prompt within the product catalog pod by running the following commands. 
Verify the secret mounted as separate files for each extracted key-value pair and corresponding environment variables set as well.

export PROD_CATALOG=$(kubectl get pods -n workshop -l app=prodcatalog -o jsonpath='{.items[].metadata.name}')
kubectl -n workshop exec -it ${PROD_CATALOG} -c prodcatalog bash

Wait for the root shell prompt within the pod. Run the following set of commands and watch the output in the pod’s shell.

export PS1='# '
cd /mnt/secrets
ls -l #--- List mounted secrets

cat dbusername; echo
cat dbpassword; echo
cat DBSecret_eksworkshop; echo

env | grep MYSQL #-- Display the MYSQL_ROOT_PASSWORD ENV variables set from the secret value
sleep 2
exit

The output shows the information as displayed here. The last exit command in the shell window exits from the pod’s shell

# cd /mnt/secrets
# ls -l   #--- List mounted secrets
total 12
-rw-r—r-- 1 root root 45 Nov 22 01:56 DBSecret_eksworkshop
-rw-r—r-- 1 root root 12 Nov 22 01:56 dbpassword
-rw-r—r-- 1 root root  3 Nov 22 01:56 dbusername
#
# cat dbusername; echo  
root
# cat dbpassword; echo
test1234
# cat DBSecret_eksworkshop; echo
{"username":"root", "password":"test1234"}
#
# env | grep MYSQL #-- Display the MYSQL_ROOT_PASSWORD ENV variables set from the secret
MYSQL_ROOT_PASSWORD=test1234
# sleep 2
# exit
exit

Notice under the path /mnt/secrets key-values pairs extracted in separate files based on jmesPath specification. Files dbusername and dbpassword contains extracted values from the JSON formatted secret DBSecret_eksworkshop

The Environment variable MYSQL_ROOT_PASSWORD is set up correctly. The ENV var mapped from the Kubernetes secrets object mysql-secret-from-secrets-manager created automatically by the CSI driver.

Confirm the presence of Kubernetes secrets. It was created automatically by the CSI driver during pod deployment.

kubectl describe secrets mysql-secret-from-secrets-manager -n workshop

Name: mysql-secret-from-secrets-manager
Namespace: workshop
Labels: secrets-store.csi.k8s.io/managed=true
Annotations: <none>

Type: Opaque

Data

db_password: 8 bytes
db_username: 4 bytes